""" Generate certificate required to leave home during Covid confinement in France

As part of the management of the Covid-19 pandemic in France, the population
may be confined at home for some weeks when the situation becomes critical.
During these periods, residents can leave their place of confinement only in
a (very) limited number of cases and are then required to bear a certificate
indicating their place of residence, the reason why they are leaving it, and
the time they are leaving it. This certificate may be hand-written, printed on
paper, or take the form of a PDF file and QR code generated by a web service
run by the authorities.

The web service requires the user to key in personal information (fist name,
last name, birth date, birth place, address of residence) every time a
certificate is to be generated.

This applet (which runs under Pythonista, on iOS) provides a convenient
alternative to the official service:

- Personal details for yourself and all the persons you are confined with need
  only be keyed in once, in file `persons.json`, in the same directory as
  the applet.

- When run, the applet displays a list of persons for whom a certificate can be
  generated.

- When a person is selected, an email is prepared, with the PDF file for the
  certificate attached, and you only have to press the send button.


**Disclaimers**

In all cases tested, this applet generates the same output (PDF file and
QR code) as the official site. However, no guarantee is provided that there
are no cases where the two differ. Furthermore, the output generated by the
official site might change without warning in the future, in which case
the applet would no longer generate the same output, until it is updated -
Use at your own risk.

The objective of this applet is to facilitate the generation of certificates,
not to work around the rules of confinement - Use in a responsible way.


**Dependencies**

- busy_view

- mail_compose

- pdfrw


**Revision history**

- 5-Avr-2020 - Created this module.

- 6-Avr-2020 - Initial release, with only QR code generation.

- 21-Avr-2020 - Second release, with PDF file generation and full UI.

- 1-Nov-2020 - Third release, with PDF file updated to the new official format.

- 28-Nov-2020 - Fourth release, with PDF file updated to the new official format. """


from dataclasses import dataclass, field as dataclass_field
from datetime import datetime, timedelta
import json
from pathlib import Path
from time import sleep
from threading import Thread
from typing import ClassVar, List
import sys

from PIL import Image, ImageDraw, ImageFont
import qrcode

from pdfrw import PageMerge, PdfReader, PdfWriter
from pdfrw.pagemerge import RectXObj


PERSONS_FILE = "persons.json"
TEMPLATE_PDF = 'attestation-deplacement-fr 2020 11 28.pdf'
CERTIFICATE_PDF = 'Attestation.pdf'
REASONS = ["travail", "achats_culturel_cultuel", "sante", "famille", "sport_animaux"]
REASONS_TITLES = ["travail", "achats", "sante", "famille", "sport"]


if sys.platform == 'ios':
    import ui
    from busy_view import BusyView
    from mail_compose import mail_compose

    CONTROLS_HEIGHT = 30
    CONTROLS_HORIZONTAL_MARGIN = 16
    CONTROLS_VERTICAL_MARGIN = 4
    SEPARATOR_COLOR = '#cccccc'    # iOS light grey

    class PersonsView(ui.View):
        """ UI for presenting a list of persons and generating certificates.


        Arguments
        ---------

        persons: `List[` :class:`Person` `]`
            List of persons to be displayed. """

        def __init__(self, persons: List["Person"]):
            self.persons = persons
            self.now = datetime.now()
            self.name = "Attestion de déplacement"
            self.flex = "WH"
            self.background_color = 'white'
            y = CONTROLS_VERTICAL_MARGIN

            self.reason_selector = ui.SegmentedControl(
                y=y,
                width=300,
                segments=REASONS_TITLES,
                selected_index=4)
            y += CONTROLS_HEIGHT + CONTROLS_VERTICAL_MARGIN

            self.generated_label1 = ui.Label(
                text=f"Créé à : {self.now.strftime('%Hh%M')} - ")
            self.generated_label1.size_to_fit()
            self.generated_label1.y = (
                y + (CONTROLS_HEIGHT - self.generated_label1.height) / 2)
            self.generated_textfield = ui.TextField(
                y=y,
                width=50,
                height=CONTROLS_HEIGHT,
                keyboard_type=ui.KEYBOARD_NUMBER_PAD,
                placeholder="0",
                delegate=self)
            self.generated_label2 = ui.Label(
                text=" min")
            self.generated_label2.size_to_fit()
            self.generated_label2.y = (
                y + (CONTROLS_HEIGHT - self.generated_label1.height) / 2)
            y += CONTROLS_HEIGHT + CONTROLS_VERTICAL_MARGIN

            self.start_label1 = ui.Label()
            self.start_textfield = ui.TextField(
                y=y,
                width=50,
                height=CONTROLS_HEIGHT,
                keyboard_type=ui.KEYBOARD_NUMBER_PAD,
                placeholder="0")
            self.start_label2 = ui.Label(
                text=" min")
            self.start_label2.size_to_fit()
            self.start_label2.y = y + (CONTROLS_HEIGHT - self.start_label2.height) / 2
            y += CONTROLS_HEIGHT + CONTROLS_VERTICAL_MARGIN

            self.separator_line = ui.View(
                y=y,
                height=1,
                border_width=1,
                border_color=SEPARATOR_COLOR)
            y += 1

            self.tableview = ui.TableView(
                y=y,
                data_source=self,
                delegate=self)

            self.busy = BusyView()

            for view in [self.reason_selector, self.start_label1,
                         self.start_textfield, self.start_label2,
                         self.generated_label1, self.generated_textfield,
                         self.generated_label2, self.separator_line,
                         self.tableview, self.busy]:
                self.add_subview(view)

        def layout(self) -> None:
            """ [ui.View] Update position and size of controls. """
            inset = self.objc_instance.safeAreaInsets()
            width = self.width - inset.left - inset.right
            height = self.height - inset.bottom
            self.reason_selector.x = (inset.left
                                      + (width - self.reason_selector.width) / 2)
            self.generated_label1.x = self.reason_selector.x
            self.generated_textfield.x = (self.generated_label1.x
                                          + self.generated_label1.width)
            self.generated_label2.x = (self.generated_textfield.x
                                       + self.generated_textfield.width)
            self.start_label1.text = (
                f"Début de sortie : {self.generated_time().strftime('%Hh%M')} + ")
            self.start_label1.size_to_fit()
            self.start_label1.x = self.reason_selector.x
            self.start_label1.y = (self.start_textfield.y
                                   + (CONTROLS_HEIGHT - self.start_label1.height) / 2)
            self.start_textfield.x = self.start_label1.x + self.start_label1.width
            self.start_label2.x = self.start_textfield.x + self.start_textfield.width
            self.separator_line.x = inset.left
            self.separator_line.width = width
            self.tableview.x = inset.left
            self.tableview.width = width
            self.tableview.height = height - self.tableview.y

        def textfield_did_change(self, textfield: ui.TextField) -> None:
            """ [ui.TextField] Update `start` field when `generated` field changes. """
            self.layout()

        def tableview_number_of_rows(self,
                                     tableview: ui.TableView,
                                     section: int) -> int:
            """ [ui.TableView] Return number rows = # persons. """
            return len(self.persons)

        def tableview_cell_for_row(self,
                                   tableview: ui.TableView,
                                   section: int,
                                   row: int) -> ui.TableViewCell:
            """ [ui.TableView] Display the first name of a given person. """
            cell = ui.TableViewCell()
            cell.selectable = False
            cell.text_label.text = self.persons[row].first_name
            return cell

        def tableview_did_select(self,
                                 tableview: ui.TableView,
                                 section: int,
                                 row: int) -> None:
            """ [ui.TableView] User selected a person. """

            def continuation():
                nonlocal self
                person = self.persons[row]
                start = self.start_time()
                pdf_file = generate_certificate_pdf(
                    person=person,
                    reason=self.reason_selector.selected_index,
                    start=start,
                    generated=self.generated_time())
                # Displaying a BusyView is necessary, because generate_certificate_pdf()
                # takes more than a fraction of a second to run. However, it does
                # not take long enough for the user to "see" BusyView, which seems
                # to flash on and off very quickly. The following extra delay is
                # only there for the user to have time to "see" BusyView before it
                # goes away.
                sleep(.3)
                self.busy.hide()
                weekdays = ['lundi', 'mardi', 'mercredi',
                            'jeudi', 'vendredi', 'samedi', 'dimanche']
                subject = (f"Attestion de déplacement - {weekdays[start.weekday()]} "
                           f"{start.strftime('%Hh%M')}")
                mail_compose(subject=subject,
                             recipients=[person.email],
                             filename=pdf_file,
                             mime_type='application/pdf')

            self.busy.show()
            Thread(target=continuation).start()

        def close_and_exit(self, sender: ui.Button) -> None:
            """ [ui.Button] Close the view and exit app. """
            self.close()

        def generated_time(self) -> datetime:
            """ Return the time the certificate was generated, as a datetime. """
            return (self.now
                    - timedelta(minutes=int(self.generated_textfield.text or '0')))

        def start_time(self) -> datetime:
            """ Return the time the certificate starts, as a datetime. """
            return (self.generated_time()
                    + timedelta(minutes=int(self.start_textfield.text or '0')))


@dataclass
class Person:
    """ Represent a person for whom a certificate can be generated. """
    first_name: str
    last_name: str
    birthdate: str
    birthplace: str
    address: str
    postal_code: str
    city: str
    email: str


@dataclass
class Field:
    """ Represent a field in the PDF certificate file. """
    x: float
    y: float
    scale: float
    filename: str = dataclass_field(init=False)
    count: ClassVar[int] = 0

    def __post_init__(self):
        self.filename = f'temp{Field.count}.pdf'
        Field.count += 1


@dataclass
class TextField(Field):
    """ Represent a text field in the PDF certificate file. """
    text: str
    font: ImageFont.FreeTypeFont

    def __post_init__(self):
        super().__post_init__()
        w, h = self.font.getsize(self.text)
        img = Image.new(mode='1', size=(w, h), color='white')
        ImageDraw.Draw(img).text((0, 0), self.text, font=self.font, fill='black')
        img.save(self.filename)


@dataclass
class QRCodeField(Field):
    """ Represent a QRCode field in the PDF certificate file. """
    person: Person
    reason: int
    start: datetime
    generated: datetime

    def __post_init__(self):
        super().__post_init__()
        QRCODE_SIZE_PX = 152  # Good compromise between image size and quality
        person = self.person
        img = qrcode.make(
            f"Cree le: {self.generated.strftime('%d/%m/%Y a %Hh%M')};\n"
            f"Nom: {person.last_name};\nPrenom: {person.first_name};\n"
            f"Naissance: {person.birthdate} a {person.birthplace};\n"
            f"Adresse: {person.address} {person.postal_code} {person.city};\n"
            f"Sortie: {self.start.strftime('%d/%m/%Y a %H:%M')};\n"
            f"Motifs: {REASONS[self.reason]}"
        ).resize(size=(QRCODE_SIZE_PX, QRCODE_SIZE_PX))
        img.save(self.filename)


def generate_certificate_pdf(person: Person,
                             reason: int,
                             start: datetime,
                             generated: datetime) -> str:
    """ Generate the certificate required when leaving the place of confinement.


    Arguments
    ---------

    person: :class:`Person`
        For whom the certificate is generated.

    reason: `int`
        For which the person is leaving her place of confinement. This is an
        index into ``REASONS``.

    start: `datetime`
        Date and time the person is leaving her place of confinement.

    generated: `datetime`
        Date and time the certificate is generated.


    Returns
    -------

    str
        Path to the PDF file generated. """

    def cm_to_point(cm: float) -> int:
        return int(cm / 2.54 * 72)

    if sys.platform == 'ios':
        LEGEND_FONT = 'Helvetica'
        LEGEND_FONT_SIZE = 24
    else:
        LEGEND_FONT = 'arial.ttf'
        LEGEND_FONT_SIZE = 24
    font = ImageFont.truetype(LEGEND_FONT, LEGEND_FONT_SIZE)

    fields = [
        TextField(text=f"{person.first_name} {person.last_name}",
                  font=font,
                  x=3.27, y=24.8, scale=.47),
        TextField(text=person.birthdate,
                  font=font,
                  x=3.27, y=24.15, scale=.47),
        TextField(text=person.birthplace,
                  font=font,
                  x=7.55, y=24.15, scale=.47),
        TextField(text=f"{person.address} {person.postal_code} {person.city} ",
                  font=font,
                  x=3.68, y=23.476, scale=.47),
        TextField(text="X" if reason == 0 else " ",
                  font=font,
                  x=1.625, y=19.52, scale=.37),
        TextField(text="X" if reason == 1 else " ",
                  font=font,
                  x=1.625, y=17.02, scale=.37),
        TextField(text="X" if reason == 2 else " ",
                  font=font,
                  x=1.625, y=15.32, scale=.37),
        TextField(text="X" if reason == 3 else " ",
                  font=font,
                  x=1.625, y=14.47, scale=.37),
        TextField(text="X" if reason == 4 else "  ",
                  font=font,
                  x=1.66, y=12.32, scale=.37),
        TextField(text=person.city,
                  font=font,
                  x=2.8, y=2.7, scale=.47),
        TextField(text=start.strftime('%d/%m/%Y'),
                  font=font,
                  x=2.22, y=2.05, scale=.47),
        TextField(text=start.strftime('%H:%M'),
                  font=font,
                  x=8.02, y=2.05, scale=.47),
        QRCodeField(person=person, reason=reason, start=start, generated=generated,
                    x=15.35, y=.9, scale=.65)
    ]

    def set_position(obj: RectXObj, x: float, y: float, scale: float) -> None:
        obj.x = cm_to_point(x)
        obj.y = cm_to_point(y)
        obj.w *= scale

    # Generate page 1
    page1_xobj = PageMerge(PdfReader(TEMPLATE_PDF).pages[0])
    for field in fields:
        pdf = PdfReader(field.filename).pages[0]
        page1_xobj.add(pdf)
        set_position(page1_xobj[-1], field.x, field.y, field.scale)
        if isinstance(field, QRCodeField):
            qrcode = pdf
    page1 = page1_xobj.render()

    # Generate page 2
    qrcode_xobj = PageMerge().add(qrcode)
    set_position(qrcode_xobj[0], 1.3, 16.9, 2.15)
    page2 = qrcode_xobj.render()
    page2.MediaBox = page1.MediaBox

    # Generate certificate document
    PdfWriter().addpages([page1, page2]).write(CERTIFICATE_PDF)

    # Remove temporary files.
    for field in fields:
        Path(field.filename).unlink()

    return CERTIFICATE_PDF


if __name__ == '__main__':
    with open(PERSONS_FILE) as file:
        persons = [Person(*person_entry) for person_entry in json.load(file)]
    if sys.platform == 'ios':
        PersonsView(persons).present()
    else:
        pdf_file = generate_certificate_pdf(
            person=persons[0],
            reason=0,
            start=datetime.now(),
            generated=datetime.now())
